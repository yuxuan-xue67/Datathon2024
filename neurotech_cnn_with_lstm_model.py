# -*- coding: utf-8 -*-
"""Neurotech - CNN with LSTM model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WAs1azLUwcU-UTl8T-t6WBGwK3oUmkIR
"""

import matplotlib.pyplot as plt
import numpy as np
import os
import pandas as pd
import numpy as np

from PIL import Image, ImageOps
import os

import torch
from torch.utils.data import Dataset, DataLoader
import torchvision
from torchvision import transforms
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
import tensorflow as tf

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Conv1D, MaxPooling1D, Flatten, LSTM, Dropout, Reshape, GlobalAveragePooling1D

from collections import defaultdict

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

from collections import Counter

# Find the count of the next most frequent class
class_distribution = Counter()
most_common_classes = class_distribution.most_common()
next_most_common_count = most_common_classes[1][1]

# Number of samples to keep from class '1'
n_samples_to_keep = next_most_common_count
# Indices of class '1' and other classes
indices_class_1 = np.where(y == 1)[0]
indices_other_classes = np.where(y != 1)[0]

# Randomly select samples from class '1'
np.random.shuffle(indices_class_1)
indices_class_1_downsampled = indices_class_1[:n_samples_to_keep]

# Combine and shuffle indices
downsampled_indices = np.concatenate([indices_class_1_downsampled, indices_other_classes])
np.random.shuffle(downsampled_indices)

# Create the downsampled dataset
X_downsampled = X[downsampled_indices]
y_downsampled = y[downsampled_indices]

# Checking the new distribution
new_class_distribution = Counter(y_downsampled)
print("Class Distribution after under-sampling:", new_class_distribution)

X_train = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training [NEW]/p00_n1_NEW_X.npy')
y_train = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training [NEW]/p00_n1_NEW_y.npy')

# CNN simple version
# Build the model
model = Sequential()
model.add(Conv1D(filters=64, kernel_size=2, activation='relu', input_shape=(6, 3000)))
model.add(MaxPooling1D(pool_size=2))
model.add(Flatten())
model.add(Dense(100, activation='relu'))
model.add(Dense(7, activation='softmax'))  # 7 classes for sleep stages

# Compile the model
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Train the model
model.fit(X_train, y_train, epochs=10, batch_size=32, validation_split=0.2)

# CNN with LSTM
# Reshape X_train for LSTM: (number of samples, time steps, features)
X_train = X_train.transpose((0, 2, 1))

# Model
model = Sequential()
model.add(LSTM(64, return_sequences=True, input_shape=(3000, 6)))
model.add(LSTM(64))
model.add(Dense(64, activation='relu'))
model.add(Dense(7, activation='softmax'))  # 7 classes for sleep stages

# Compile and train
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
model.fit(X_train, y_train, epochs=5, validation_split=0.2)

# Load test data
X_test = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training [NEW]/p09_n1_NEW_X.npy')
y_test = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training [NEW]/p09_n1_NEW_y.npy')

# Reshape X_test for LSTM: (number of samples, time steps, features)
X_test = X_test.transpose((0, 2, 1))

# Evaluate the model on the test data
test_loss, test_accuracy = model.evaluate(X_test, y_test)
print(f"Test Loss: {test_loss}")
print(f"Test Accuracy: {test_accuracy}")

import matplotlib.pyplot as plt
# Predict the labels for the test set
y_pred = model.predict(X_test)
y_pred_classes = np.argmax(y_pred, axis=1)
# Assuming y_pred_classes is your array of predicted sleep stages
# And let's say you have an array of epoch numbers corresponding to these predictions
epochs = range(len(y_pred_classes))

# Create a line plot
plt.figure(figsize=(15, 6))  # Set the figure size
plt.plot(epochs, y_pred_classes, label='Predicted Sleep Stages', color='b')
plt.xlabel('Epoch Number')
plt.ylabel('Sleep Stage')
plt.title('Predicted Sleep Stages over Epochs')
plt.legend()
plt.show()

import numpy as np
from sklearn.preprocessing import StandardScaler

def load_and_preprocess(file_x, file_y):
    # Load data
    X = np.load(file_x)
    y = np.load(file_y)

    # Reshape X if necessary (depends on your model's input requirements)
    # For example, if using a CNN with channels last, you might reshape like so:
    # X = X.transpose((0, 2, 1))

    # Normalize data
    # Flatten the epochs and channels for normalization then reshape back
    original_shape = X.shape
    X_flattened = X.reshape(-1, X.shape[-1])
    scaler = StandardScaler()
    X_normalized = scaler.fit_transform(X_flattened)
    X = X_normalized.reshape(original_shape)

    return X, y

# Example usage
X_p1, y_p1 = load_and_preprocess('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p00_n1_X.npy', '/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p00_n1_y.npy')
X_p2, y_p2 = load_and_preprocess('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p01_n1_X.npy', '/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p01_n1_y.npy')
# ... Load more datasets as required

# Combine the data
X_combined = np.concatenate([X_p1, X_p2], axis=0)  # Add more datasets as required
y_combined = np.concatenate([y_p1, y_p2], axis=0)  # Similarly, concatenate the labels

# Shuffle the combined data to ensure good mixing
# It's important to shuffle both features and labels in unison
perm = np.random.permutation(len(X_combined))
X_combined = X_combined[perm]
y_combined = y_combined[perm]

X_combined.shape

X_test = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p00_n2_X.npy')
y_test = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p00_n2_y.npy')

# Evaluate the model
test_loss, test_accuracy = model.evaluate(X_test, y_test)
print(f"Test Loss: {test_loss}")
print(f"Test Accuracy: {test_accuracy}")

# For detailed classification metrics
from sklearn.metrics import classification_report, confusion_matrix

# Predict the labels for the test set
y_pred = model.predict(X_test)
y_pred_classes = np.argmax(y_test, axis=1)

# Print classification report
print(classification_report(y_test, y_pred_classes))

# Print confusion matrix
print(confusion_matrix(y_test, y_pred_classes))

import matplotlib.pyplot as plt

# Assuming y_pred_classes is your array of predicted sleep stages
# And let's say you have an array of epoch numbers corresponding to these predictions
epochs = range(len(y_pred_classes))

# Create a line plot
plt.figure(figsize=(15, 6))  # Set the figure size
plt.plot(epochs, y_pred_classes, label='Predicted Sleep Stages', color='b')
plt.xlabel('Epoch Number')
plt.ylabel('Sleep Stage')
plt.title('Predicted Sleep Stages over Epochs')
plt.legend()
plt.show()

# Load data
p00_n1_X = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training [NEW]/p00_n1_NEW_X.npy')
p00_n1_y = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training [NEW]/p00_n1_NEW_y.npy')
p01_n1_X = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training [NEW]/p01_n1_NEW_X.npy')
p01_n1_y = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training [NEW]/p01_n1_NEW_y.npy')
# p02_n1_X = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training [NEW]/p02_n1_NEW_X.npy')
# p02_n1_y = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p02_n1_y.npy')
# p03_n1_X = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p03_n1_X.npy')
# p03_n1_y = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p03_n1_y.npy')
# p04_n1_X = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p04_n1_X.npy')
# p04_n1_y = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p04_n1_y.npy')
# p05_n1_X = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p05_n1_X.npy')
# p05_n1_y = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p05_n1_y.npy')
# p06_n1_X = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p06_n1_X.npy')
# p06_n1_y = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p06_n1_y.npy')
# p07_n1_X = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p07_n1_X.npy')
# p07_n1_y = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p07_n1_y.npy')

datasets = [(p00_n1_X[:, 3:6, :], p00_n1_y), (p01_n1_X[:, 3:6, :], p01_n1_y)]

# datasets = [(p00_n1_X, p00_n1_y), (p01_n1_X, p01_n1_y), (p02_n1_X, p02_n1_y),(p03_n1_X, p03_n1_y),(p04_n1_X, p04_n1_y),(p05_n1_X, p05_n1_y),(p06_n1_X, p06_n1_y), (p07_n1_X, p07_n1_y)]

# # Assuming y_pred is the array of predicted sleep stages from your Random Forest model
# # And assuming epochs is a sequence of epoch indices corresponding to y_pred
# epochs = range(len(y_pred))

# # Create a line plot
# plt.figure(figsize=(15, 5))  # Set the figure size to be large enough to see details
# plt.plot(epochs, y_pred, label='Predicted Sleep Stages', color='blue', marker='o', linestyle='-', markersize=3)
# plt.xlabel('Epoch Number')
# plt.ylabel('Predicted Sleep Stage')
# plt.title('Predicted Sleep Stages over Epochs')
# plt.legend()
# plt.grid(True)  # Optional: Add grid for better readability
# plt.tight_layout()  # Adjust the padding of the plot
# plt.show()
# Assuming y_pred_classes is your array of predicted sleep stages
# And let's say you have an array of epoch numbers corresponding to these predictions
epochs = range(len(y_pred))

# Create a line plot
plt.figure(figsize=(15, 6))  # Set the figure size
plt.plot(epochs, y_pred, label='Predicted Sleep Stages', color='b')
plt.xlabel('Epoch Number')
plt.ylabel('Sleep Stage')
plt.title('Predicted Sleep Stages over Epochs')
plt.legend()
plt.show()

for i, (X_downsampled, y_downsampled) in enumerate(datasets):
    print(f"Training on dataset {i+1}...")
    model = create_model()

    # Train the model
    model.fit(X_downsampled, y_downsampled, epochs=10, batch_size=32, validation_split=0.2)

    # Evaluate the model
    test_loss, test_accuracy = model.evaluate(X_downsampled, y_downsampled)
    print(f"Dataset {i+1} - Test Loss: {test_loss}, Test Accuracy: {test_accuracy}")

X_test = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training [NEW]/p09_n1_NEW_X.npy')
y_test = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training [NEW]/p09_n1_NEW_y.npy')

# Evaluate the model on the test set
test_loss, test_accuracy = model.evaluate(X_test[:, 3:6, :], y_test)
print(f"Test Loss: {test_loss}")
print(f"Test Accuracy: {test_accuracy}")

# Predict the labels for the test set
y_pred = model.predict(X_test[:, 3:6, :])
y_pred_classes = np.argmax(y_pred, axis=1)  # Corrected line

# Print classification report
print(classification_report(y_test, y_pred_classes))

# Print confusion matrix
print(confusion_matrix(y_test, y_pred_classes))

import matplotlib.pyplot as plt

# Assuming y_pred_classes is your array of predicted sleep stages
# And let's say you have an array of epoch numbers corresponding to these predictions
epochs = range(len(y_pred_classes))

# Create a line plot
plt.figure(figsize=(15, 6))  # Set the figure size
plt.plot(epochs, y_pred_classes, label='Predicted Sleep Stages', color='b')
plt.xlabel('Epoch Number')
plt.ylabel('Sleep Stage')
plt.title('Predicted Sleep Stages over Epochs')
plt.legend()
plt.show()

# Load data
p00_n1_X = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p00_n1_X.npy')
p00_n1_y = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p00_n1_y.npy')
p01_n1_X = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p01_n1_X.npy')
p01_n1_y = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p01_n1_y.npy')

datasets = [(p00_n1_X, p00_n1_y), (p01_n1_X, p01_n1_y)]

from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

X_test = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p00_n2_X.npy')
y_test = np.load('/content/drive/My Drive/Datathon 2024/Neurotech@Rice Datathon Challenge/Training/p00_n2_y.npy')

# Preprocess test data (the same way you preprocessed training data)
# If your test data is 3D (N x Channels x Time), you need to flatten it to 2D (N x Features)
X_test_flattened = X_test.reshape(X_test.shape[0], -1)

# Predict using the trained model
y_pred = rf_clf.predict(X_test_flattened)

# Evaluate the predictions
accuracy = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy}')
print(classification_report(y_test, y_pred))
print(confusion_matrix(y_test, y_pred))

import matplotlib.pyplot as plt

# Assuming y_pred_classes is your array of predicted sleep stages
# And let's say you have an array of epoch numbers corresponding to these predictions
epochs = range(len(y_pred_classes))

# Create a line plot
plt.figure(figsize=(15, 6))  # Set the figure size
plt.plot(epochs, y_pred_classes, label='Predicted Sleep Stages', color='b')
plt.xlabel('Epoch Number')
plt.ylabel('Sleep Stage')
plt.title('Predicted Sleep Stages over Epochs')
plt.legend()
plt.show()